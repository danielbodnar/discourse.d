import Anthropic from "@anthropic-ai/sdk";

const anthropic = new Anthropic({
  // defaults to process.env["ANTHROPIC_API_KEY"]
  apiKey: "my_api_key",
});

// Replace placeholders like {{EXISTING_DOCKERFILE_OR_CONTAINER}} with real values,
// because the SDK does not support variables.
const msg = await anthropic.messages.create({
  model: "claude-3-5-sonnet-20241022",
  max_tokens: 8192,
  temperature: 0,
  messages: [
    {
      "role": "user",
      "content": [
        {
          "type": "text",
          "text": "<examples>\n<example>\n<EXISTING_DOCKERFILE_OR_CONTAINER>\n# Use an official Discourse base image\nFROM bitnami/discourse:3.2.2\n\n# Set environment variables\nENV DISCOURSE_HOSTNAME=mydiscourse.example.com\nENV DISCOURSE_DEVELOPER_EMAILS=admin@example.com\nENV DISCOURSE_SMTP_ADDRESS=smtp.example.com\nENV DISCOURSE_SMTP_PORT=587\nENV DISCOURSE_SMTP_USER_NAME=smtpuser\nENV DISCOURSE_SMTP_PASSWORD=smtppassword\n\n# Install additional packages\nUSER root\nRUN apt-get update && apt-get install -y \\\n    imagemagick \\\n    ffmpeg \\\n    && apt-get clean \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Switch back to non-root user\nUSER 1001\n\n# Expose ports\nEXPOSE 3000\n\n# Set the default command to run Discourse\nCMD [\"./app-entrypoint.sh\"]\n</EXISTING_DOCKERFILE_OR_CONTAINER>\n<USER_CONFIG>\n{\n  \"containerRegistry\": {\n    \"url\": \"registry.example.com\",\n    \"username\": \"myuser\",\n    \"password\": \"mypassword\"\n  },\n  \"baseImage\": {\n    \"name\": \"bitnami/discourse\",\n    \"tag\": \"3.2.2\"\n  },\n  \"buildArgs\": {\n    \"DISCOURSE_VERSION\": \"3.2.2\"\n  },\n  \"environmentVariables\": {\n    \"DISCOURSE_HOSTNAME\": \"mydiscourse.example.com\",\n    \"DISCOURSE_DEVELOPER_EMAILS\": \"admin@example.com\",\n    \"DISCOURSE_SMTP_ADDRESS\": \"smtp.example.com\",\n    \"DISCOURSE_SMTP_PORT\": \"587\",\n    \"DISCOURSE_SMTP_USER_NAME\": \"smtpuser\",\n    \"DISCOURSE_SMTP_PASSWORD\": \"smtppassword\"\n  },\n  \"proxySettings\": {\n    \"httpProxy\": \"http://proxy.example.com:8080\",\n    \"httpsProxy\": \"http://proxy.example.com:8080\",\n    \"noProxy\": \"localhost,127.0.0.1\"\n  },\n  \"caCertificates\": [\n    \"/path/to/custom-ca.crt\"\n  ],\n  \"osPackages\": [\n    \"imagemagick\",\n    \"ffmpeg\"\n  ],\n  \"appSources\": {\n    \"repoUrl\": \"https://github.com/myuser/discourse-custom-plugin.git\",\n    \"branch\": \"main\"\n  },\n  \"customConfigurations\": {\n    \"discourse.conf\": \"content_security_policy = false\\nmax_reqs_per_ip_per_minute = 120\"\n  },\n  \"buildSteps\": [\n    \"bundle install\",\n    \"yarn install\",\n    \"rake assets:precompile\"\n  ],\n  \"testCommands\": [\n    \"bundle exec rspec\"\n  ],\n  \"lifecycleHooks\": {\n    \"preStart\": \"bundle exec rake db:migrate\",\n    \"postStart\": \"bundle exec rake jobs:work\"\n  },\n  \"userAndGroups\": {\n    \"user\": \"discourse\",\n    \"uid\": 1001,\n    \"group\": \"discourse\",\n    \"gid\": 1001\n  },\n  \"volumesAndMounts\": [\n    {\n      \"name\": \"discourse-data\",\n      \"mountPath\": \"/bitnami/discourse\"\n    }\n  ],\n  \"exposedPorts\": [3000],\n  \"runtimeScripts\": [\n    {\n      \"name\": \"start-discourse\",\n      \"content\": \"#!/bin/bash\\n./app-entrypoint.sh\"\n    }\n  ]\n}\n</USER_CONFIG>\n<TECHSTACK>\n- [bun](https://github.com/bun-sh/bun)\n- [unjs/citty](https://github.com/unjs/citty)\n- [unjs/consola](https://github.com/unjs/consola)\n- [unjs/c12](https://github.com/unjs/c12)\n- [unjs/magicast](https://github.com/unjs/magicast)\n- [unjs/defu](https://github.com/unjs/defu)\n- llamaindexts\n- ollama.js\n- Node.js 22\n- Docker and Docker compose\n- Linux Containers and Filesystem Hierarchy Standard 3.0\n\n```json\n{\n  \"name\": \"dockerfile-generator\",\n  \"version\": \"1.0.0\",\n  \"module\": \"index.ts\",\n  \"type\": \"module\",\n  \"devDependencies\": {\n    \"bun-types\": \"latest\"\n  },\n  \"dependencies\": {\n    \"@anthropic-ai/sdk\": \"^0.18.0\",\n    \"c12\": \"^1.10.0\",\n    \"citty\": \"^0.1.5\",\n    \"consola\": \"^3.2.3\",\n    \"defu\": \"^6.1.4\",\n    \"llamaindex\": \"^0.1.7\",\n    \"magicast\": \"^0.3.3\",\n    \"ollama\": \"^0.4.9\",\n    \"zod\": \"^3.22.4\",\n    \"zod-to-json-schema\": \"^3.22.3\"\n  }\n}\n```\n</TECHSTACK>\n<KNOWLEDGE_REQUIREMENTS>\nTo effectively use this Dockerfile generator script, users should have knowledge in the following areas:\n\n1. Docker fundamentals:\n   - Understanding of Dockerfile syntax and best practices\n   - Docker image layers and caching\n   - Docker networking and volume management\n\n2. Bun runtime and shell scripting:\n   - Basic Bun syntax and command-line usage\n   - Understanding of shell scripting concepts\n\n3. Container orchestration:\n   - Familiarity with container registries and image distribution\n   - Basic understanding of container lifecycle management\n\n4. Web application deployment:\n   - Knowledge of web server configurations (e.g., Nginx)\n   - Understanding of application server requirements (e.g., Ruby on Rails)\n\n5. Database systems:\n   - Basic understanding of database containers (e.g., PostgreSQL, Redis)\n\n6. Security best practices:\n   - Knowledge of least privilege principles\n   - Understanding of secure environment variable usage\n\n7. CI/CD concepts:\n   - Familiarity with build and test processes in containerized environments\n\n8. Node.js ecosystem:\n   - Basic understanding of npm/yarn package management\n   - Familiarity with JavaScript/TypeScript\n\n9. Zod and JSON schema:\n   - Understanding of data validation and schema definition\n\n10. AI and machine learning concepts:\n    - Basic familiarity with AI-assisted code generation\n    - Understanding of prompt engineering for AI models\n\n11. Version control systems:\n    - Knowledge of Git and GitHub for managing application source code\n\n12. Networking concepts:\n    - Understanding of ports, proxies, and network configurations in containerized environments\n\nThis knowledge will help users navigate the script's prompts, understand the generated Dockerfile, and make informed decisions about their container configuration.\n\nPlease generate a Dockerfile for our Discourse forum application with the following specific requirements:\n\n1. Use the bitnami/discourse:3.2.2 as the base image.\n2. Set up the necessary environment variables for our Discourse instance, including SMTP settings.\n3. Install additional packages: imagemagick and ffmpeg.\n4. Add our custom Discourse plugin from our GitHub repository.\n5. Configure content security policy to be disabled and increase the max requests per IP per minute to 120.\n6. Ensure that the container runs as a non-root user (UID 1001).\n7. Set up a volume for persistent data storage.\n8. Expose port 3000 for web traffic.\n9. Include a runtime script to start Discourse with proper initialization.\n10. Add build steps to install dependencies and precompile assets.\n11. Include a test command to run the test suite.\n12. Set up lifecycle hooks for database migrations and background job processing.\n\nPlease make sure the Dockerfile is optimized for production use, with proper layering to minimize image size and improve build times. Also, include comments in the Dockerfile to explain each significant step for future maintenance.\n</KNOWLEDGE_REQUIREMENTS>\n<INSTRUCTIONS>\n\nYour task is to create a Bun shell script that will prompt the user for variables and configuration values and use those to generate a Dockerfile or OCI rootfs directory.\n\nThe bun shell guide is here : https://bun.sh/docs/runtime/shell\n\nThe following steps will need to be configured:\n\n- container registry\n- base image\n- build args\n- environment variables\n- proxy and no_proxy values\n- ca-certificates\n- os packages (intelligently determine package manager)\n- app sources and repos\n- custom configurations\n- layered overlays and\n- build steps\n- test commands\n- lifecycle hooks\n- user and groups\n- volumes and mounts\n- exposed ports\n- runtime scripts\n\nEverything should be configurable and generic.\n\nUse bun as the node js runtime, package manager, and bash shell environment.\nUse citty, consola, magicast, and c12 to prompt the user for configuration values, then save them to \"./docker.config.ts\" with c12 and magicast. Use Zod and zod-to-json-schema to create a zod-object per configuration section above. Use Consola to prompt the user for values, and those Zod schemas to determine defaults, prompt types (multi select, string, int, etc), and zod's \".describe()\" key to determine the text to display to the user while promoting them for a configuration value.\n\nThe very this script should do is prompt the user for a docker image or a docker container or a Dockerfile and then attempt to extract and infer as many of these values from the container image, Dockerfile, or docker container.\n\nThis CLI should also provide an option for using ollama.js,  llamaindexts, or '@anthropic-ai/sdk' and 'claude3-5-sonnet-latest' to generate the actual Dockerfile by using the Zod schemas as a tool calling input schema.\n\nI'll help you create a comprehensive Bun shell script for Dockerfile generation. Let's break this down into multiple files for better organization:\n\n1. First, create a `package.json`:\n\n```json\n{\n  \"name\": \"dockerfile-generator\",\n  \"version\": \"1.0.0\",\n  \"module\": \"index.ts\",\n  \"type\": \"module\",\n  \"devDependencies\": {\n    \"bun-types\": \"latest\"\n  },\n  \"dependencies\": {\n    \"@anthropic-ai/sdk\": \"^0.18.0\",\n    \"c12\": \"^1.10.0\",\n    \"citty\": \"^0.1.5\",\n    \"consola\": \"^3.2.3\",\n    \"defu\": \"^6.1.4\",\n    \"llamaindex\": \"^0.1.7\",\n    \"magicast\": \"^0.3.3\",\n    \"ollama\": \"^0.4.9\",\n    \"zod\": \"^3.22.4\",\n    \"zod-to-json-schema\": \"^3.22.3\"\n  }\n}\n```\n\n2. Create `src/schemas/index.ts` for Zod schemas:\n\n```typescript\nimport { z } from 'zod';\n\nexport const ContainerRegistrySchema = z.object({\n  url: z.string().url().describe('Container registry URL'),\n  username: z.string().describe('Registry username'),\n  password: z.string().describe('Registry password')\n}).describe('Container registry configuration');\n\nexport const BaseImageSchema = z.object({\n  name: z.string().default('archlinux').describe('Base image name'),\n  tag: z.string().default('latest').describe('Base image tag')\n}).describe('Base image configuration');\n\nexport const BuildArgsSchema = z.record(z.string()).describe('Build arguments');\n\nexport const EnvironmentVariablesSchema = z.record(z.string()).describe('Environment variables');\n\nexport const ProxySettingsSchema = z.object({\n  httpProxy: z.string().optional().describe('HTTP proxy URL'),\n  httpsProxy: z.string().optional().describe('HTTPS proxy URL'),\n  noProxy: z.string().optional().describe('No proxy list')\n}).describe('Proxy settings');\n\nexport const CaCertificatesSchema = z.array(z.string()).describe('CA certificates');\n\nexport const OSPackagesSchema = z.array(z.string()).describe('OS packages to install');\n\nexport const AppSourcesSchema = z.object({\n  repoUrl: z.string().url().optional().describe('Repository URL'),\n  branch: z.string().default('main').describe('Repository branch')\n}).describe('Application source configuration');\n\nexport const CustomConfigurationsSchema = z.record(z.string()).describe('Custom configurations');\n\nexport const BuildStepsSchema = z.array(z.string()).describe('Build steps');\n\nexport const TestCommandsSchema = z.array(z.string()).describe('Test commands');\n\nexport const LifecycleHooksSchema = z.object({\n  preStart: z.string().optional().describe('Pre-start hook'),\n  postStart: z.string().optional().describe('Post-start hook')\n}).describe('Lifecycle hooks');\n\nexport const UserAndGroupsSchema = z.object({\n  user: z.string().describe('Container user'),\n  uid: z.number().describe('User ID'),\n  group: z.string().describe('Container group'),\n  gid: z.number().describe('Group ID')\n}).describe('User and groups configuration');\n\nexport const VolumesAndMountsSchema = z.array(\n  z.object({\n    name: z.string().describe('Volume name'),\n    mountPath: z.string().describe('Mount path')\n  })\n).describe('Volumes and mounts configuration');\n\nexport const ExposedPortsSchema = z.array(z.number()).describe('Exposed ports');\n\nexport const RuntimeScriptsSchema = z.array(\n  z.object({\n    name: z.string().describe('Script name'),\n    content: z.string().describe('Script content')\n  })\n).describe('Runtime scripts');\n\nexport const DockerConfigSchema = z.object({\n  containerRegistry: ContainerRegistrySchema,\n  baseImage: BaseImageSchema,\n  buildArgs: BuildArgsSchema,\n  environmentVariables: EnvironmentVariablesSchema,\n  proxySettings: ProxySettingsSchema,\n  caCertificates: CaCertificatesSchema,\n  osPackages: OSPackagesSchema,\n  appSources: AppSourcesSchema,\n  customConfigurations: CustomConfigurationsSchema,\n  buildSteps: BuildStepsSchema,\n  testCommands: TestCommandsSchema,\n  lifecycleHooks: LifecycleHooksSchema,\n  userAndGroups: UserAndGroupsSchema,\n  volumesAndMounts: VolumesAndMountsSchema,\n  exposedPorts: ExposedPortsSchema,\n  runtimeScripts: RuntimeScriptsSchema\n}).describe('Complete Docker configuration');\n```\n\n3. Create `src/utils/docker-parser.ts`:\n\n```typescript\nimport { $ } from 'bun';\n\nexport async function parseDockerfile(path: string) {\n  try {\n    const content = await Bun.file(path).text();\n    // Parse Dockerfile content and extract configuration\n    // This is a simplified example\n    return {\n      baseImage: {\n        name: content.match(/FROM\\s+(\\w+)/)?.[1] || 'archlinux',\n        tag: content.match(/FROM\\s+\\w+:(\\w+)/)?.[1] || 'latest'\n      },\n      // Add more parsing logic for other sections\n    };\n  } catch (error) {\n    console.error('Error parsing Dockerfile:', error);\n    return null;\n  }\n}\n\nexport async function inspectContainer(containerName: string) {\n  try {\n    const { stdout } = await $`docker inspect ${containerName}`;\n    const inspection = JSON.parse(stdout);\n    // Extract configuration from container inspection\n    return {\n      // Convert inspection data to config format\n    };\n  } catch (error) {\n    console.error('Error inspecting container:', error);\n    return null;\n  }\n}\n```\n\n4. Create `src/generators/dockerfile.ts`:\n\n```typescript\nimport type { DockerConfig } from '../types';\n\nexport function generateDockerfile(config: DockerConfig): string {\n  const parts: string[] = [];\n\n  // Base image\n  parts.push(`FROM ${config.baseImage.name}:${config.baseImage.tag}`);\n\n  // Environment variables\n  Object.entries(config.environmentVariables).forEach(([key, value]) => {\n    parts.push(`ENV ${key}=${value}`);\n  });\n\n  // OS packages\n  if (config.osPackages.length > 0) {\n    // Detect package manager based on base image\n    const packageManager = getPackageManager(config.baseImage.name);\n    parts.push(generatePackageInstallation(packageManager, config.osPackages));\n  }\n\n  // User and groups\n  parts.push(`\nRUN groupadd -g ${config.userAndGroups.gid} ${config.userAndGroups.group} && \\\n    useradd -u ${config.userAndGroups.uid} -g ${config.userAndGroups.group} ${config.userAndGroups.user}\n  `);\n\n  // Add more sections based on config\n\n  return parts.join('\\n\\n');\n}\n\nfunction getPackageManager(baseImage: string): string {\n  const packageManagers = {\n    'archlinux': 'pacman -Sy',\n    'ubuntu': 'apt-get update && apt-get install -y',\n    'alpine': 'apk add --no-cache',\n    // Add more package managers\n  };\n  return packageManagers[baseImage] || 'pacman -Sy';\n}\n\nfunction generatePackageInstallation(packageManager: string, packages: string[]): string {\n  return `RUN ${packageManager} ${packages.join(' ')}`;\n}\n```\n\n5. Create the main script `dockerfile-generator.ts`:\n\n```typescript\n#!/usr/bin/env bun\n\nimport { consola } from 'consola';\nimport { defineCommand } from 'citty';\nimport { defineConfig } from 'c12';\nimport { DockerConfigSchema } from './src/schemas';\nimport { parseDockerfile, inspectContainer } from './src/utils/docker-parser';\nimport { generateDockerfile } from './src/generators/dockerfile';\nimport { Ollama } from 'ollama';\nimport { AnthropicClient } from '@anthropic-ai/sdk';\n\nconst main = defineCommand({\n  meta: {\n    name: 'dockerfile-generator',\n    description: 'Generate Dockerfile from configuration',\n  },\n  async run({ args }) {\n    try {\n      // Step 1: Get existing configuration\n      const existingConfig = await getExistingConfig();\n\n      // Step 2: Prompt for configuration values\n      const config = await promptForConfig(existingConfig);\n\n      // Step 3: Save configuration\n      await saveConfig(config);\n\n      // Step 4: Generate Dockerfile\n      const useAI = await consola.confirm('Use AI to generate Dockerfile?');\n      const dockerfile = useAI\n        ? await generateDockerfileWithAI(config)\n        : generateDockerfile(config);\n\n      // Step 5: Save Dockerfile\n      await Bun.write('Dockerfile', dockerfile);\n      consola.success('Dockerfile generated successfully!');\n\n    } catch (error) {\n      consola.error('Error generating Dockerfile:', error);\n      process.exit(1);\n    }\n  }\n});\n\nasync function getExistingConfig() {\n  const source = await consola.prompt(\n    'Enter path to existing Dockerfile or container name (optional):'\n  );\n\n  if (!source) return null;\n\n  if (source.includes('Dockerfile')) {\n    return await parseDockerfile(source);\n  } else {\n    return await inspectContainer(source);\n  }\n}\n\nasync function promptForConfig(existingConfig: any) {\n  // Implementation of configuration prompting\n  // Use consola to prompt for each configuration section\n  // Validate input using Zod schemas\n}\n\nasync function saveConfig(config: any) {\n  await defineConfig({\n    name: 'docker',\n    defaults: config,\n    layers: [{\n      config,\n      configFile: './docker.config.ts'\n    }]\n  });\n}\n\nasync function generateDockerfileWithAI(config: any) {\n  const aiProvider = await consola.select('Choose AI provider:', [\n    'Ollama',\n    'Claude'\n  ]);\n\n  const prompt = `Generate a Dockerfile with these requirements:\n    ${JSON.stringify(config, null, 2)}`;\n\n  switch (aiProvider) {\n    case 'Ollama':\n      const ollama = new Ollama();\n      const response = await ollama.generate({\n        model: 'codellama',\n        prompt\n      });\n      return response.text;\n\n    case 'Claude':\n      const claude = new AnthropicClient({\n        apiKey: process.env.ANTHROPIC_API_KEY\n      });\n      const completion = await claude.messages.create({\n        model: 'claude-3-sonnet-20240229',\n        max_tokens: 4096,\n        messages: [{\n          role: 'user',\n          content: prompt\n        }]\n      });\n      return completion.content[0].text;\n  }\n}\n\n// Run the command\nmain.parse(process.argv);\n```\n\nThis implementation provides a solid foundation for a Dockerfile generator with:\n\n- Structured schema definitions\n- Existing configuration parsing\n- Interactive configuration prompting\n- AI-assisted generation\n- Configuration persistence\n- Modular and maintainable code structure\n\nTo use the script:\n\n1. Install dependencies:\n```bash\nbun install\n```\n\n2. Make the script executable:\n```bash\nchmod +x dockerfile-generator.ts\n```\n\n3. Run the generator:\n```bash\n./dockerfile-generator.ts\n```\n\nYou can extend this further by:\n\n- Adding more validation rules to schemas\n- Implementing more sophisticated Dockerfile parsing\n- Adding support for more AI providers\n- Implementing configuration templates\n- Adding support for different base images and package managers\n\n</INSTRUCTIONS>\n<ideal_output>\nBased on your detailed requirements, I'll help you create a well-structured Bun shell script for Dockerfile generation. Let's break this down into multiple files for better organization and maintainability.\n\n1. First, create `src/schemas/docker.config.ts`:\n\n```typescript\nimport { z } from 'zod';\n\nexport const ContainerRegistrySchema = z.object({\n  url: z.string().url().describe('Container registry URL'),\n  username: z.string().optional().describe('Registry username'),\n  password: z.string().optional().describe('Registry password')\n}).describe('Container registry configuration');\n\nexport const BaseImageSchema = z.object({\n  name: z.string().default('archlinux').describe('Base image name'),\n  tag: z.string().default('latest').describe('Base image tag')\n}).describe('Base image configuration');\n\nexport const ProxySettingsSchema = z.object({\n  httpProxy: z.string().optional().describe('HTTP proxy URL'),\n  httpsProxy: z.string().optional().describe('HTTPS proxy URL'),\n  noProxy: z.string().optional().describe('No proxy list')\n}).describe('Proxy settings');\n\nexport const PackageManagerSchema = z.enum(['pacman', 'apt', 'apk', 'yum', 'dnf'])\n  .describe('Package manager');\n\nexport const OSPackagesSchema = z.array(\n  z.string()\n).describe('OS packages to install');\n\n// Add more schemas for other sections...\n\nexport const DockerConfigSchema = z.object({\n  containerRegistry: ContainerRegistrySchema,\n  baseImage: BaseImageSchema,\n  proxySettings: ProxySettingsSchema,\n  packageManager: PackageManagerSchema,\n  osPackages: OSPackagesSchema,\n  // Include other schemas...\n}).describe('Complete Docker configuration');\n\nexport type DockerConfig = z.infer<typeof DockerConfigSchema>;\n```\n\n2. Create `src/utils/docker-parser.ts`:\n\n```typescript\nimport { $ } from 'bun';\nimport type { DockerConfig } from '../schemas/docker.config';\n\nexport async function parseExistingDocker(source: string): Promise<Partial<DockerConfig>> {\n  if (source.includes('Dockerfile')) {\n    return parseDockerfile(source);\n  } else {\n    return parseContainer(source);\n  }\n}\n\nasync function parseDockerfile(path: string): Promise<Partial<DockerConfig>> {\n  const content = await Bun.file(path).text();\n  \n  const baseImage = content.match(/FROM\\s+([^\\s]+)/)?.[1]?.split(':') || [];\n  const packages = content.match(/RUN\\s+(pacman|apt-get|apk)\\s+install\\s+([^\\n]+)/)?.[2]?.split(/\\s+/) || [];\n  \n  return {\n    baseImage: {\n      name: baseImage[0] || 'archlinux',\n      tag: baseImage[1] || 'latest'\n    },\n    osPackages: packages\n  };\n}\n\nasync function parseContainer(name: string): Promise<Partial<DockerConfig>> {\n  try {\n    const { stdout } = await $`docker inspect ${name}`;\n    const info = JSON.parse(stdout)[0];\n    \n    return {\n      baseImage: {\n        name: info.Config.Image.split(':')[0],\n        tag: info.Config.Image.split(':')[1] || 'latest'\n      },\n      // Extract more configuration...\n    };\n  } catch (error) {\n    console.error('Error inspecting container:', error);\n    return {};\n  }\n}\n```\n\n3. Create `src/generators/dockerfile-generator.ts`:\n\n```typescript\nimport type { DockerConfig } from '../schemas/docker.config';\n\nexport function generateDockerfile(config: DockerConfig): string {\n  const parts: string[] = [];\n  \n  // Base image\n  parts.push(`FROM ${config.baseImage.name}:${config.baseImage.tag}`);\n  \n  // Proxy settings\n  if (config.proxySettings.httpProxy) {\n    parts.push(`ENV HTTP_PROXY=${config.proxySettings.httpProxy}`);\n    parts.push(`ENV http_proxy=${config.proxySettings.httpProxy}`);\n  }\n  \n  // Package installation\n  if (config.osPackages.length > 0) {\n    const installCommand = getPackageInstallCommand(config.packageManager, config.osPackages);\n    parts.push(installCommand);\n  }\n  \n  // Add more sections based on config...\n  \n  return parts.join('\\n\\n');\n}\n\nfunction getPackageInstallCommand(manager: string, packages: string[]): string {\n  const commands = {\n    pacman: `RUN pacman -Syu --noconfirm ${packages.join(' ')}`,\n    apt: `RUN apt-get update && apt-get install -y ${packages.join(' ')}`,\n    apk: `RUN apk add --no-cache ${packages.join(' ')}`\n  };\n  \n  return commands[manager] || commands.pacman;\n}\n```\n\n4. Create the main script `dockerfile-generator.ts`:\n\n```typescript\n#!/usr/bin/env bun\n\nimport { consola } from 'consola';\nimport { defineCommand } from 'citty';\nimport { defineConfig } from 'c12';\nimport { Ollama } from 'ollama';\nimport { AnthropicClient } from '@anthropic-ai/sdk';\nimport { DockerConfigSchema } from './src/schemas/docker.config';\nimport { parseExistingDocker } from './src/utils/docker-parser';\nimport { generateDockerfile } from './src/generators/dockerfile-generator';\n\nconst main = defineCommand({\n  meta: {\n    name: 'dockerfile-generator',\n    description: 'Generate Dockerfile from configuration'\n  },\n  args: {\n    source: {\n      type: 'string',\n      description: 'Existing Dockerfile or container name',\n      required: false\n    }\n  },\n  async run({ args }) {\n    try {\n      // Step 1: Parse existing configuration\n      const existingConfig = args.source \n        ? await parseExistingDocker(args.source)\n        : {};\n      \n      // Step 2: Prompt for configuration\n      const config = await promptForConfig(existingConfig);\n      \n      // Step 3: Save configuration\n      await saveConfig(config);\n      \n      // Step 4: Generate Dockerfile\n      const useAI = await consola.confirm('Use AI to generate Dockerfile?');\n      const dockerfile = useAI\n        ? await generateDockerfileWithAI(config)\n        : generateDockerfile(config);\n      \n      // Step 5: Save Dockerfile\n      await Bun.write('Dockerfile', dockerfile);\n      consola.success('Dockerfile generated successfully!');\n      \n    } catch (error) {\n      consola.error('Error:', error);\n      process.exit(1);\n    }\n  }\n});\n\nasync function promptForConfig(existing = {}) {\n  const config = {};\n  \n  for (const [key, schema] of Object.entries(DockerConfigSchema.shape)) {\n    const defaultValue = existing[key] || schema._def.defaultValue;\n    const description = schema.description;\n    \n    if (schema instanceof z.ZodArray) {\n      config[key] = await consola.multiselect({\n        message: description,\n        options: defaultValue || []\n      });\n    } else {\n      config[key] = await consola.prompt({\n        type: 'text',\n        message: description,\n        initial: defaultValue\n      });\n    }\n  }\n  \n  return config;\n}\n\nasync function saveConfig(config) {\n  await defineConfig({\n    name: 'docker',\n    defaults: config,\n    layers: [{\n      config,\n      configFile: './docker.config.ts'\n    }]\n  });\n}\n\nasync function generateDockerfileWithAI(config) {\n  const aiProvider = await consola.select('Choose AI provider:', [\n    'Ollama',\n    'Claude'\n  ]);\n  \n  const prompt = `Generate a Dockerfile with these requirements:\n    ${JSON.stringify(config, null, 2)}`;\n  \n  switch (aiProvider) {\n    case 'Ollama':\n      const ollama = new Ollama();\n      const response = await ollama.generate({\n        model: 'codellama',\n        prompt\n      });\n      return response.text;\n      \n    case 'Claude':\n      const claude = new AnthropicClient({\n        apiKey: process.env.ANTHROPIC_API_KEY\n      });\n      const completion = await claude.messages.create({\n        model: 'claude-3-sonnet-20240229',\n        max_tokens: 4096,\n        messages: [{\n          role: 'user',\n          content: prompt\n        }]\n      });\n      return completion.content[0].text;\n  }\n}\n\nmain.parse(process.argv);\n```\n\nTo use the script:\n\n1. Install dependencies:\n```bash\nbun install\n```\n\n2. Make the script executable:\n```bash\nchmod +x dockerfile-generator.ts\n```\n\n3. Run the generator:\n```bash\n./dockerfile-generator.ts\n```\n\nThis implementation provides:\n- Schema-based configuration validation\n- Intelligent parsing of existing Dockerfiles/containers\n- Interactive configuration prompting\n- AI-assisted Dockerfile generation\n- Configuration persistence\n- Modern package management with Bun\n\nThe script is modular and can be easily extended with additional features and configuration options.\n</ideal_output>\n</example>\n</examples>\n\n"
        },
        {
          "type": "text",
          "text": "You are tasked with creating a Bun shell script that will generate a Dockerfile or OCI rootfs directory based on user input and configuration values. This script should be highly configurable and generic, capable of handling various aspects of container configuration.\n\nFirst, analyze the following existing Dockerfile or container information:\n\n<existing_dockerfile_or_container>\n{{EXISTING_DOCKERFILE_OR_CONTAINER}}\n</existing_dockerfile_or_container>\n\nNext, review the configuration values specified by the user:\n\n<user_config>\n{{USER_CONFIG}}\n</user_config>\n\n\nThird, review the tech stack requirements:\n<teckstack>\n{{TECHSTACK}}\n</techstack>\n\nFourth, familiarize yourself with the following knowledge prerequisites:\n\n<knowledge_requirements>\n{{KNOWLEDGE_REQUIREMENTS}}\n</knowledge_requirements>\n\n\nFinally, review the user's custom instructions:\n\n<instructions>\n{{INSTRUCTIONS}}\n</instructions>\n\n\nYour task is to create a Bun shell script that will prompt the user for variables and configuration values and use those to generate a Dockerfile or OCI rootfs directory. \n\nThe bun shell guide is here : https://bun.sh/docs/runtime/shell\n\nThe following steps will need to be configured: \n\n- container registry\n- base image\n- build args\n- environment variables\n- proxy and no_proxy values\n- ca-certificates \n- os packages (intelligently determine package manager) \n- app sources and repos \n- custom configurations\n- layered overlays and \n- build steps\n- test commands\n- lifecycle hooks \n- user and groups \n- volumes and mounts \n- exposed ports\n- runtime scripts \n\nEverything should be configurable and generic. \n\nUse bun as the node js runtime, package manager, and bash shell environment. \nUse citty, consola, magicast, and c12 to prompt the user for configuration values, then save them to \"./docker.config.ts\" with c12 and magicast. Use Zod and zod-to-json-schema to create a zod-object per configuration section above. Use Consola to prompt the user for values, and those Zod schemas to determine defaults, prompt types (multi select, string, int, etc), and zod's \".describe()\" key to determine the text to display to the user while promoting them for a configuration value.\n\nThe very this script should do is prompt the user for a docker image or a docker container or a Dockerfile and then attempt to extract and infer as many of these values from the container image, Dockerfile, or docker container.\n\nThis CLI should also provide an option for using ollama.js,  llamaindexts, or '@anthropic-ai/sdk' and 'claude3-5-sonnet-latest' to generate the actual Dockerfile by using the Zod schemas as a tool calling input schema. \n\nUse archlinux as a default container example.\n\n\nNow, follow these steps to create the Bun shell script:\n\n1. Set up the Bun shell script environment:\n   - Create a new file named `dockerfile-generator.ts`\n   - At the top of the file, add the shebang line: `#!/usr/bin/env bun`\n\n2. Import and configure the necessary libraries:\n   ```typescript\n   import { $, file } from 'bun';\n   import { consola } from 'consola';\n   import { z } from 'zod';\n   import { zodToJsonSchema } from 'zod-to-json-schema';\n   import { defineConfig } from 'c12';\n   import { createMagicGetter, createMagicSetter } from 'magicast';\n   import { Ollama } from 'ollama';\n   import { Document } from 'llamaindex';\n   import { AnthropicClient } from '@anthropic-ai/sdk';\n   ```\n\n3. Create Zod schemas for each configuration section:\n   ```typescript\n   const ContainerRegistrySchema = z.object({\n     // Define schema for container registry\n   }).describe('Container registry configuration');\n\n   const BaseImageSchema = z.object({\n     // Define schema for base image\n   }).describe('Base image configuration');\n\n   // Create similar schemas for all other configuration sections\n   ```\n\n4. Extract and infer values from the existing Dockerfile or container:\n   - Implement a function to parse the existing_dockerfile_or_container input\n   - Extract relevant information for each configuration section\n   - Store the extracted values in an object for later use\n\n5. Prompt the user for configuration values using Consola and Zod schemas:\n   ```typescript\n   async function promptForConfig(schema: z.ZodObject<any>, existingValues: any) {\n     const result = {};\n     for (const [key, value] of Object.entries(schema.shape)) {\n       const defaultValue = existingValues[key] || value._def.defaultValue();\n       const description = value.description;\n       result[key] = await consola.prompt(`${description} (default: ${defaultValue})`);\n     }\n     return result;\n   }\n\n   const containerRegistryConfig = await promptForConfig(ContainerRegistrySchema, extractedValues.containerRegistry);\n   const baseImageConfig = await promptForConfig(BaseImageSchema, extractedValues.baseImage);\n   // Prompt for all other configuration sections\n   ```\n\n6. Save the configuration to docker.config.ts using c12 and magicast:\n   ```typescript\n   const config = {\n     containerRegistry: containerRegistryConfig,\n     baseImage: baseImageConfig,\n     // Include all other configuration sections\n   };\n\n   await defineConfig({\n     name: 'docker',\n     defaults: config,\n     layers: [\n       {\n         config: createMagicSetter(config),\n         configFile: file('./docker.config.ts'),\n       },\n     ],\n   });\n   ```\n\n7. Generate the Dockerfile using the configuration values:\n   ```typescript\n   function generateDockerfile(config: any) {\n     let dockerfile = '';\n     // Use the config object to generate each section of the Dockerfile\n     // Example:\n     dockerfile += `FROM ${config.baseImage.name}:${config.baseImage.tag}\\n`;\n     // Add all other Dockerfile instructions based on the config\n     return dockerfile;\n   }\n\n   const generatedDockerfile = generateDockerfile(config);\n   await Bun.write('Dockerfile', generatedDockerfile);\n   ```\n\n8. Implement AI-assisted Dockerfile generation option:\n   ```typescript\n   async function generateDockerfileWithAI(config: any) {\n     const prompt = `Generate a Dockerfile based on the following configuration:\\n${JSON.stringify(config, null, 2)}`;\n     \n     // Choose one of the following AI options:\n     \n     // Option 1: Ollama\n     const ollama = new Ollama();\n     const response = await ollama.generate({\n       model: 'codellama',\n       prompt: prompt,\n     });\n     \n     // Option 2: LlamaIndex\n     const document = new Document({ text: prompt });\n     const response = await document.retrieve();\n     \n     // Option 3: Anthropic Claude\n     const client = new AnthropicClient({ apiKey: process.env.ANTHROPIC_API_KEY });\n     const response = await client.complete({\n       model: 'claude-3-sonnet-20241022',\n       prompt: prompt,\n       max_tokens_to_sample: 8192,\n     });\n     \n     return response.text;\n   }\n\n   // Prompt user to choose between manual or AI-assisted generation\n   const useAI = await consola.confirm('Do you want to use AI to generate the Dockerfile?');\n   const finalDockerfile = useAI ? await generateDockerfileWithAI(config) : generateDockerfile(config);\n   await Bun.write('Dockerfile', finalDockerfile);\n   ```\n\n9. Conclusion and output:\n   Print a success message and the location of the generated Dockerfile:\n   ```typescript\n   consola.success('Dockerfile generated successfully!');\n   consola.info(`Dockerfile location: ${process.cwd()}/Dockerfile`);\n   ```\n\nEnsure that your script handles errors gracefully and provides clear feedback to the user throughout the process. The final output should be a generated Dockerfile based on the user's configuration choices, with an option to use AI assistance for generation."
        }
      ]
    }
  ]
});
console.log(msg);
